# Rockpool Detective - GA Project One - 7 Days

![Rockpool Detective](https://)

Rockpool Detective is based on the classic code-breaking game Mastermind.  A hidden pattern of four Rockpool Creatures is generated at the start of each game and the player must try to guess the correct pattern within six attempts. The player is given clues based on how close they are to the correct pattern as they go, which helps them to inform their next guess. 

## Deployment link

The project was deployed using xxx and can be experienced [here](https://bit.ly/Rockpool-Detective).

## Brief 
* The game should be playable for one player with the computer creating the code to guess.
* Once the game has been completed the player should be able to play again.

## Timeframe

The time allocated to complete this project was one week. This was a solo project and was completed during week four of the GA Software Engineering Immersive course.

## Technologies Used
JavaScript, HTML, CSS.

## Planning

### Project management

![Imgur](https://)
I used Trello to plan the project which enabled me to keep all notes and ideas in the same place, map a timeline and monitor progress. This kept me focussed and helped with achieving the key goals of the brief. 

### Wireframe

![Wireframe](https://)
Using a wireframe (drawn with [Excalidraw](https://excalidraw.com)) helped me visualize the HTML components, as well as ideas for styling the user interface.

### Pseudocode

I wrote a framework for JavaScript in plain English, including the elements, variables, executions and events. I included methods and the logic I planned to use. 

##  Build Process

I spent day one planning: understanding the brief, researching the game, creating a timeline, setting goals, and generating the wireframe and pseudocode. My approach meant that by day two I was able to complete the HTML and get the styling to the minimal viable product.

### Making the decoding and clue grids
As the  decoding and clue grids are the central part of the game, it was key to get these made early on. Initially, I used JavaScript to the grids dynamically, however it was evident after trying for a long time to manipulate them into the correct grid/row formation and place them side by side, I was not going to achieve the desired placement without compromising the progress of the project.  Since these grids were not going to be used for character movement (e.g as in Pac Man),  I decided to instead hard code them in HTML, then style with CSS using display:flex and display:grid

### Creating the random code and player choice
The secret code was randomly generated by selecting 4 items from the choiceArray:

Random series of choices was generated using Math.random() and pushed into the empty computerCurrentChoiceArray

The player choice was made using a click , which also corresponded with the values in the choiceArray. I used the forEach method to add the event listener . Each creature had a class of “choice” and its own ID.

The playerChoice function added player selected choices into the playerCurrentChoiceArray. Once the length of the array as equal to four, no further choices were added.

Later I created the disableChoices() with a removeEventListener to disable the click event.

### Preparing the grids for play

In this game, each row of the grid is equivalent to a round of the game. During each round, four choices are placed in a row in the decoding grid,before being appraised with clues. 

I therefore needed to transform my HTML list into arrays of four decodingCells (“rows”). These 6 arrays are held within the “rowsArray”. The starting row is actually the bottom of the grid and the last array of cells in the rowsArray, hence the currentRow variable. 

Similarly for the clue cells, I created a function called “prepareClue” in which the “cellsArray” is built, containing six “cells” arrays , each with four targetable clueCells within them. These correspond to the number of clues which can be awarded each round. 


### Displaying player choice in the DOM
This is a function that displays  the values in the playerChoice array, based on the index of the decodingCell in the current row.  
The updateDOMRow() function is then called within playerChoice().

### Comparing the randomly generated secret code with the players chosen code
Initially I used multiple array methods, however a simpler solution was to create objects for the player and the computer and pass the “full” or “partial” matches into these. 		The diagram shows how the partial and full matching process works

First full matches were checked. I cycled through the computerCurrentChoiceArray and compared it one by one with the values in the playerCurrentChoiceArray. The value and the index position is compared, and if both match the value full is added into both the player and computer arrays at the corresponding key (e.g. “starfish” direct match and ‘full is added to key 3 in both objects. 

### Comparing the partial matches….more info here

### Giving clues to the player choice
I targeted the DOM elements for the clue grid  (clue cells) in the same way, to display the “partial” and “full” matches. The matches are generated and passed into the empty clueArray at the end of each round. 

## Challenges

The main difficulty in this project was the logic behind comparing the player choice against the randomly generated code. Comparing full matches was more straightforward, but the partial matches were more problematic, as I didn't want duplicates in the players, or any of the full matches to be counted twice.

## Wins
* Responsive design for smaller screens and phones
* Strong visual design and theme

## Key Learning Points

* Understanding the importance of creating a good plan, and working through things one step at a time. 
* Feeling more adept at using CSS
* Appreciating the value of DRY code and use of semantic naming
* Improved understanding of classes 
* Utilizing vanilla JavaScript for DOM manipulation 

## Bugs

I am aware of an issue with white clue keys when the game is restarted using the play again function. 

## Future Improvements

* Refactor some of the code (e.g. make. the playerWon) a function and restructure the code.
* Refine the CSS to make it a little more DRY.
* Make it possible to clear one row on the decoding grid, rather than resetting the entire game if the player wishes to change their choice.
* Enable the player to drag and drop choices, and move them around on the decoding grid until they are happy, then submit guesses for each row via a button click. 
* Game difficulty could be altered e.g made easier for children with fewer choices, shorter rows and more guesses (longer grid). 
* I could include more CSS keyframes animation to make it more visually appealing, for example highlighting the player choices using border pulse or shaking the Play Again button after Game Over.








